<!DOCTYPE html>
<html>
<head>
    <title>ShinobiWay</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            background-image: url('/back.png');
            background-repeat: no-repeat;
            background-size: cover;
            color: #fff;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .output {
            width: 80%;
            height: 300px;
            background-color: #333;
            overflow-y: auto;
            padding: 10px;
            margin: 10px;
            border: 2px solid #fff;
        }
        .controls {
            width: 80%;
            margin: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }
        .status {
            width: 80%;
            margin: 10px;
            padding: 10px;
            border: 2px solid #fff;
        }
        .skill-count {
            width: 80%;
            margin: 10px;
            padding: 10px;
            border: 2px solid #fff;
            text-align: center;
        }
        button {
            background-color: #555;
            color: #fff;
            border: 2px solid #fff;
            padding: 5px 10px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #777;
        }
        .fire {
            background-color: #ff0000;
        }
        .lightning {
            background-color: #ffa500;
        }
        .illusion {
            background-color: #800080;
        }
        .earth {
            background-color: #8b4513;
        }
        .feral {
            background-color: #228b22;
        }
        .neutral {
            background-color: #555;
        }
        .start-button {
            background-color: #555;
            color: #fff;
            border: 2px solid #fff;
            font-size: 1.5rem;
            padding: 10px 20px;
        }
        .skills-button, .train-button {
            background-color: #555;
            color: #fff;
            border: 2px solid #fff;
            font-size: 1.2rem;
            padding: 5px 10px;
        }
        .output-text-player {
            color: #00ff00;
        }
        .output-text-enemy {
            color: #ff00ff;
        }
        .output-text-neutral {
            color: #ccc;
        }
        .status-burn {
            color: #ff0000;
        }
        .status-numb {
            color: #ffa500;
        }
        .status-bleed {
            color: #ff00ff;
        }
        .status-healing {
            color: #00ff00;
        }
        .status-doom {
            color: #ffffff;
        }
        .status-shadowcloneeffect {
            color: #800080;
        }
        .status-substitution {
            color: #8b4513;
        }
        .status-rockbarrier {
            color: #228b22;
        }
        .sprite {
            width: 50px;
            height: 50px;
            vertical-align: middle;
        }
        .player-hp {
            color: #00ff00;
        }
        .enemy-hp {
            color: #ff00ff;
        }
        .skills-popup {
            background: #333;
            color: #fff;
            padding: 20px;
            border: 2px solid #fff;
        }
        .close-button {
            background: #555;
            color: #fff;
            border: 2px solid #fff;
            font-size: 1.2rem;
            padding: 5px 10px;
            cursor: pointer;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="status" id="player-status">Shinobi [HP: <span class="player-hp">10/10</span>]</div>
    <div class="status" id="enemy-status">Enemy [HP: <span class="enemy-hp">0/0</span>]</div>
    <div class="skill-count" id="skill-count">Skill cards: 0 | Gold: 0</div>
    <div class="output" id="output">Welcome to ShinobiWay!</div>
    <div class="controls" id="start-controls">
        <button class="start-button" onclick="startGame()">Start Game</button>
    </div>
    <div class="controls" id="style-controls"></div>
    <div class="controls" id="jutsu-controls"></div>
    <div class="controls" id="skill-controls"></div>
    <div class="controls" id="main-controls"></div>
    <div class="output" id="log">Log started...</div>

    <script>
        let game = {
            player: {
                name: "Shinobi",
                hp: 10,
                maxHp: 10,
                Rank: "Student",
                ninjaStyles: { Ninjutsu: "D-Rank", Taijutsu: "D-Rank", Genjutsu: "D-Rank", Fire: "D-Rank", Lightning: "D-Rank", Illusion: "D-Rank", Earth: "D-Rank", Feral: "D-Rank" },
                skills: [],
                skillInventory: [],
                statusEffects: []
            },
            enemy: null,
            battleNum: 1,
            output: [],
            gameState: "start",
            battleScene: null,
            outputQueue: [],
            isOutputting: false,
            gold: 0
        };

        class StatusEffect {
            constructor(name, duration, damage = 0) {
                this.name = name;
                this.duration = duration;
                this.damage = damage;
                this.new = true;
            }
        }

        class BattleSkill {
            constructor(name, attributes, requirements, skillFunction, style, support, rank) {
                this.name = name;
                this.attributes = attributes || [];
                this.requirements = requirements || {};
                this.skillFunction = skillFunction;
                this.style = style;
                this.support = support || false;
                this.rank = rank;
            }
        }

        class Mob {
            constructor(name, hp, maxHp, Rank, ninjaStyles, skills, statusEffects, sprite) {
                this.name = name;
                this.hp = hp;
                this.maxHp = maxHp;
                this.Rank = Rank;
                this.ninjaStyles = ninjaStyles;
                this.skills = skills;
                this.statusEffects = statusEffects || [];
                this.sprite = sprite;
            }
        }

        class Skills {
            constructor() {
                this.skills = [];
                this.initializeSkills();
            }

            initializeSkills() {
                this.skills = [
                    new BattleSkill("Barrage", [], {}, this.barrage.bind(this), "neutral", false, "D-Rank"),
                    new BattleSkill("Demon Mind Jutsu", ["Illusion"], { Illusion: "C-Rank" }, this.demonMindJutsu.bind(this), "illusion", false, "C-Rank"),
                    new BattleSkill("Fireball Jutsu", ["Fire"], { Fire: "C-Rank" }, this.fireballJutsu.bind(this), "fire", false, "C-Rank"),
                    new BattleSkill("Flame Throw Jutsu", ["Fire"], { Fire: "B-Rank" }, this.flameThrowJutsu.bind(this), "fire", false, "B-Rank"),
                    new BattleSkill("Healing Stance", [], {}, this.healingStance.bind(this), "neutral", true, "D-Rank"),
                    new BattleSkill("Shock Field Jutsu", ["Lightning"], { Lightning: "C-Rank" }, this.shockFieldJutsu.bind(this), "lightning", false, "C-Rank"),
                    new BattleSkill("Shadow Clone Jutsu", ["Illusion"], { Illusion: "C-Rank" }, this.shadowCloneJutsu.bind(this), "illusion", true, "C-Rank"),
                    new BattleSkill("Bite", ["Feral"], { Feral: "C-Rank" }, this.bite.bind(this), "feral", false, "C-Rank"),
                    new BattleSkill("Substitution", [], {}, this.substitution.bind(this), "neutral", true, "D-Rank"),
                    new BattleSkill("Rock Barrier Jutsu", ["Earth"], { Earth: "C-Rank" }, this.rockBarrierJutsu.bind(this), "earth", true, "C-Rank"),
                    new BattleSkill("Impending Doom", ["Illusion"], { Illusion: "B-Rank" }, this.impendingDoom.bind(this), "illusion", false, "B-Rank"),
                    new BattleSkill("Rock Smash Jutsu", ["Earth"], { Earth: "B-Rank" }, this.rockSmashJutsu.bind(this), "earth", false, "B-Rank"),
                    new BattleSkill("Storm Release Jutsu", ["Lightning"], { Lightning: "A-Rank" }, this.stormReleaseJutsu.bind(this), "lightning", false, "A-Rank"),
                    new BattleSkill("Ultimate Shadow Clone", ["Illusion"], { Illusion: "S-Rank" }, this.ultimateShadowClone.bind(this), "illusion", true, "S-Rank")
                ];
            }

            canUseSkill(mob, skill) {
                return Object.keys(skill.requirements).every(key => mob.ninjaStyles[key] && compareRanks(mob.ninjaStyles[key], skill.requirements[key]) >= 0);
            }

            findSkill(name) {
                return this.skills.find(skill => skill.name === name);
            }

            barrage(user, target, scene) {
                let baseDamage = Math.round(Math.random()) + 1;
                let comboDamage = Math.round(Math.random()) + 1;
                target.hp = Math.max(0, Math.min(target.maxHp, target.hp - baseDamage));
                scene.queueOutput(`<span class="output-text-${user === game.player ? 'player' : 'enemy'}">${user.name}</span> attacks <span class="output-text-${target === game.player ? 'player' : 'enemy'}">${target.name}</span> with <span class="output-text-neutral">Barrage</span> and hits for ${baseDamage} damage!`);
                if (target.hp > 0) {
                    target.hp = Math.max(0, Math.min(target.maxHp, target.hp - comboDamage));
                    scene.queueOutput(`<span class="output-text-${user === game.player ? 'player' : 'enemy'}">${user.name}</span> combos for ${comboDamage} damage!`);
                }
                if (target.hp <= 0) return true;
                return false;
            }

            demonMindJutsu(user, target, scene) {
                let damage = 2;
                target.hp = Math.max(0, Math.min(target.maxHp, target.hp - damage));
                target.statusEffects.push(new StatusEffect("Doom", 3, 2));
                scene.queueOutput(`<span class="output-text-${user === game.player ? 'player' : 'enemy'}">${user.name}</span> casts <span class="output-text-illusion">Demon Mind Jutsu</span> on <span class="output-text-${target === game.player ? 'player' : 'enemy'}">${target.name}</span> for ${damage} damage, inflicting <span class="status-doom">Doom üíÄ</span>!`);
                if (target.hp <= 0) return true;
                return false;
            }

            fireballJutsu(user, target, scene) {
                let damage = Math.round(Math.random()) + 3;
                target.hp = Math.max(0, Math.min(target.maxHp, target.hp - damage));
                target.statusEffects.push(new StatusEffect("Burn", 3, 1));
                scene.queueOutput(`<span class="output-text-${user === game.player ? 'player' : 'enemy'}">${user.name}</span> casts <span class="output-text-fire">Fireball Jutsu</span> on <span class="output-text-${target === game.player ? 'player' : 'enemy'}">${target.name}</span> for ${damage} damage, inflicting <span class="status-burn">Burn üî•</span>!`);
                if (target.hp <= 0) return true;
                return false;
            }

            flameThrowJutsu(user, target, scene) {
                let damage = Math.round(Math.random()) + 5;
                target.hp = Math.max(0, Math.min(target.maxHp, target.hp - damage));
                target.statusEffects.push(new StatusEffect("Burn", 3, 1));
                scene.queueOutput(`<span class="output-text-${user === game.player ? 'player' : 'enemy'}">${user.name}</span> casts <span class="output-text-fire">Flame Throw Jutsu</span> on <span class="output-text-${target === game.player ? 'player' : 'enemy'}">${target.name}</span> for ${damage} damage, inflicting <span class="status-burn">Burn üî•</span>!`);
                if (target.hp <= 0) return true;
                return false;
            }

            healingStance(user, target, scene) {
                let heal = user.hp < user.maxHp ? 1 : 0;
                user.hp = Math.max(0, Math.min(user.maxHp, user.hp + heal));
                user.statusEffects.push(new StatusEffect("Healing", 3, 1));
                scene.queueOutput(`<span class="output-text-${user === game.player ? 'player' : 'enemy'}">${user.name}</span> enters <span class="output-text-neutral">Healing Stance</span>${heal > 0 ? `, healing ${heal} HP` : ""} <span class="status-healing">üåø</span>!`);
                return true;
            }

            shockFieldJutsu(user, target, scene) {
                let damage = Math.round(Math.random() * 2) + 2;
                target.hp = Math.max(0, Math.min(target.maxHp, target.hp - damage));
                user.statusEffects.push(new StatusEffect("Numb", 1));
                target.statusEffects.push(new StatusEffect("Numb", 1));
                scene.queueOutput(`<span class="output-text-${user === game.player ? 'player' : 'enemy'}">${user.name}</span> uses <span class="output-text-lightning">Shock Field Jutsu</span> on <span class="output-text-${target === game.player ? 'player' : 'enemy'}">${target.name}</span> for ${damage} damage, inflicting <span class="status-numb">Numb ‚ö°Ô∏è</span> on both!`);
                if (target.hp <= 0) return true;
                return false;
            }

            shadowCloneJutsu(user, target, scene) {
                if (user.hp < 2) {
                    scene.queueOutput(`<span class="output-text-${user === game.player ? 'player' : 'enemy'}">${user.name}</span> does not have enough HP to cast <span class="output-text-illusion">Shadow Clone Jutsu</span>!`);
                    return false;
                }
                let cloneCount = user.statusEffects.filter(e => e.name === "ShadowCloneEffect").length;
                if (cloneCount >= 3) {
                    scene.queueOutput(`<span class="output-text-${user === game.player ? 'player' : 'enemy'}">${user.name}</span> already has the maximum of 3 shadow clones!`);
                    return false;
                }
                user.hp = Math.max(0, Math.min(user.maxHp, user.hp - 2));
                user.statusEffects.push(new StatusEffect("ShadowCloneEffect", 3));
                scene.queueOutput(`<span class="output-text-${user === game.player ? 'player' : 'enemy'}">${user.name}</span> casts <span class="output-text-illusion">Shadow Clone Jutsu</span>, adding a clone <span class="status-shadowcloneeffect">üë•</span>!`);
                return true;
            }

            bite(user, target, scene) {
                let damage = 1;
                let heal = user.hp < user.maxHp ? 1 : 0;
                user.hp = Math.max(0, Math.min(user.maxHp, user.hp + heal));
                target.hp = Math.max(0, Math.min(target.maxHp, target.hp - damage));
                target.statusEffects.push(new StatusEffect("Bleed", 3, 2));
                scene.queueOutput(`<span class="output-text-${user === game.player ? 'player' : 'enemy'}">${user.name}</span> uses <span class="output-text-feral">Bite</span> on <span class="output-text-${target === game.player ? 'player' : 'enemy'}">${target.name}</span> for ${damage} damage${heal > 0 ? `, healing ${heal} HP` : ""}, inflicting <span class="status-bleed">Bleed ü©∏</span>!`);
                if (target.hp <= 0) return true;
                return false;
            }

            substitution(user, target, scene) {
                user.statusEffects.push(new StatusEffect("Substitution", 3));
                scene.queueOutput(`<span class="output-text-${user === game.player ? 'player' : 'enemy'}">${user.name}</span> prepares <span class="output-text-neutral">Substitution</span> <span class="status-substitution">ü™µ</span>!`);
                return true;
            }

            rockBarrierJutsu(user, target, scene) {
                user.statusEffects.push(new StatusEffect("RockBarrier", 2));
                scene.queueOutput(`<span class="output-text-${user === game.player ? 'player' : 'enemy'}">${user.name}</span> raises <span class="output-text-earth">Rock Barrier Jutsu</span> <span class="status-rockbarrier">ü™®</span>!`);
                return true;
            }

            impendingDoom(user, target, scene) {
                let damage = 4;
                target.hp = Math.max(0, Math.min(target.maxHp, target.hp - damage));
                target.statusEffects.push(new StatusEffect("Doom", 5, 2));
                scene.queueOutput(`<span class="output-text-${user === game.player ? 'player' : 'enemy'}">${user.name}</span> casts <span class="output-text-illusion">Impending Doom</span> on <span class="output-text-${target === game.player ? 'player' : 'enemy'}">${target.name}</span> for ${damage} damage, inflicting <span class="status-doom">Doom üíÄ</span>!`);
                if (target.hp <= 0) return true;
                return false;
            }

            rockSmashJutsu(user, target, scene) {
                let damage = Math.round(Math.random()) + 4;
                target.hp = Math.max(0, Math.min(target.maxHp, target.hp - damage));
                scene.queueOutput(`<span class="output-text-${user === game.player ? 'player' : 'enemy'}">${user.name}</span> uses <span class="output-text-earth">Rock Smash Jutsu</span> on <span class="output-text-${target === game.player ? 'player' : 'enemy'}">${target.name}</span> for ${damage} damage!`);
                if (target.hp <= 0) return true;
                return false;
            }

            stormReleaseJutsu(user, target, scene) {
                let damage = Math.round(Math.random() * 3) + 5;
                target.hp = Math.max(0, Math.min(target.maxHp, target.hp - damage));
                target.statusEffects.push(new StatusEffect("Numb", 2));
                scene.queueOutput(`<span class="output-text-${user === game.player ? 'player' : 'enemy'}">${user.name}</span> unleashes <span class="output-text-lightning">Storm Release Jutsu</span> on <span class="output-text-${target === game.player ? 'player' : 'enemy'}">${target.name}</span> for ${damage} damage, inflicting <span class="status-numb">Numb ‚ö°Ô∏è</span>!`);
                if (target.hp <= 0) return true;
                return false;
            }

            ultimateShadowClone(user, target, scene) {
                if (user.hp < 3) {
                    scene.queueOutput(`<span class="output-text-${user === game.player ? 'player' : 'enemy'}">${user.name}</span> does not have enough HP to cast <span class="output-text-illusion">Ultimate Shadow Clone</span>!`);
                    return false;
                }
                let cloneCount = user.statusEffects.filter(e => e.name === "UltimateShadowCloneEffect").length;
                if (cloneCount >= 5) {
                    scene.queueOutput(`<span class="output-text-${user === game.player ? 'player' : 'enemy'}">${user.name}</span> already has the maximum of 5 ultimate shadow clones!`);
                    return false;
                }
                user.hp = Math.max(0, Math.min(user.maxHp, user.hp - 3));
                user.statusEffects.push(new StatusEffect("UltimateShadowCloneEffect", 5));
                scene.queueOutput(`<span class="output-text-${user === game.player ? 'player' : 'enemy'}">${user.name}</span> casts <span class="output-text-illusion">Ultimate Shadow Clone</span>, adding an ultimate clone <span class="status-shadowcloneeffect">üë•</span>!`);
                return true;
            }
        }

        function compareRanks(rank1, rank2) {
            const ranks = ["D-Rank", "C-Rank", "B-Rank", "A-Rank", "S-Rank"];
            return ranks.indexOf(rank1) - ranks.indexOf(rank2);
        }

        function log(msg) {
            const el = document.getElementById('log');
            el.innerHTML += '<br>' + msg;
        }

        function updateStatus() {
            document.getElementById("player-status").innerHTML = `${game.player.name} [HP: <span class="player-hp">${game.player.hp}/${game.player.maxHp}</span>]`;
            document.getElementById("enemy-status").innerHTML = `Enemy [HP: <span class="enemy-hp">${game.enemy ? game.enemy.hp + "/" + game.enemy.maxHp : "0/0"}</span>] ${game.enemy ? game.enemy.name : ""}`;
        }

        function updateSkillCount() {
            let totalCards = game.player.skills.length + game.player.skillInventory.length;
            document.getElementById("skill-count").innerText = `Skill cards: ${totalCards} | Gold: ${game.player.gold}`;
            if (totalCards >= 10 && game.player.Rank === "Student") {
                game.player.Rank = "Genin";
                queueOutput(`<span class="genin">Promoted to Genin!</span>`);
                log('Promoted to Genin!');
            }
        }

        function startGame() {
            log('Starting game at ' + new Date().toLocaleTimeString() + '...');
            if (game.gameState === "start") {
                game.output = ["Train to earn gold and skills! Aim for 10 skills to become a Genin!"];
                document.getElementById("output").innerHTML = game.output.join("<br>");
                game.gameState = "chooseStyles";
                log('Setting up style selection...');
                setupStyleButtons();
                updateSkillCount();
                document.getElementById("start-controls").innerHTML = "";
            }
        }

        function setupStyleButtons() {
            let controls = document.getElementById("style-controls");
            controls.innerHTML = "";
            let allStyles = ["Ninjutsu", "Taijutsu", "Genjutsu", "Fire", "Lightning", "Illusion", "Earth", "Feral"];
            allStyles.forEach(style => {
                let button = document.createElement("button");
                button.innerText = style;
                button.onclick = function() { selectStyle(style); };
                controls.appendChild(button);
                log('Added ' + style + ' button');
            });
        }

        function selectStyle(style) {
            log('Selecting ' + style + '...');
            if (game.player.ninjaStyles[style] && Object.values(game.player.ninjaStyles).filter(r => r !== "D-Rank").length < 2) {
                if (confirm("Select " + style + "?")) {
                    game.player.ninjaStyles[style] = upgradeRank(game.player.ninjaStyles[style]);
                    log(style + ' added as a style with rank upgraded to ' + game.player.ninjaStyles[style] + '!');
                    if (Object.values(game.player.ninjaStyles).filter(r => r !== "D-Rank").length === 2) {
                        log('Both styles selected, proceeding to initial jutsu selection...');
                        document.getElementById("style-controls").innerHTML = "";
                        setupInitialJutsuSelection();
                    }
                }
            }
        }

        function upgradeRank(rank) {
            const ranks = ["D-Rank", "C-Rank", "B-Rank", "A-Rank", "S-Rank"];
            let currentIndex = ranks.indexOf(rank);
            return currentIndex < ranks.length - 1 ? ranks[currentIndex + 1] : rank;
        }

        function setupInitialJutsuSelection() {
            game.gameState = "chooseInitialJutsu";
            performJutsuSelection(3);
        }

        function performJutsuSelection(times) {
            if (times > 0) {
                let controls = document.getElementById("jutsu-controls");
                controls.innerHTML = "";
                let skillSet = new Skills();
                let availableJutsu = skillSet.skills.filter(skill => skillSet.canUseSkill(game.player, skill));
                let randomJutsu = [];
                for (let i = 0; i < 3 && availableJutsu.length > 0; i++) {
                    let index = Math.floor(Math.random() * availableJutsu.length);
                    randomJutsu.push(availableJutsu.splice(index, 1)[0]);
                }
                if (randomJutsu.length > 0) {
                    randomJutsu.forEach(jutsu => {
                        let button = document.createElement("button");
                        button.innerText = jutsu.name;
                        button.onclick = function() { selectJutsu(jutsu, () => performJutsuSelection(times - 1)); };
                        controls.appendChild(button);
                    });
                } else {
                    log('No jutsu available based on styles and ranks.');
                    showMainScreen();
                }
            } else {
                log('Initial jutsu selection complete, returning to main screen...');
                showMainScreen();
            }
        }

        function selectJutsu(jutsu, callback) {
            log('Selecting ' + jutsu.name + '...');
            if (game.gameState === "chooseInitialJutsu" || game.gameState === "postBattle") {
                if (game.player.skills.length + game.player.skillInventory.length < 10 || jutsu.rank === "D-Rank" || jutsu.rank === "C-Rank") {
                    game.player.skillInventory.push(jutsu);
                    log(jutsu.name + ' added to skill inventory!');
                    updateSkillCount();
                    document.getElementById("jutsu-controls").innerHTML = "";
                    if (callback) callback();
                } else {
                    game.player.gold += jutsu.rank === "D-Rank" ? 5 : jutsu.rank === "C-Rank" ? 10 : 50;
                    log(`Extra ${jutsu.name} converted to ${jutsu.rank === "D-Rank" ? 5 : jutsu.rank === "C-Rank" ? 10 : 50} gold!`);
                    updateSkillCount();
                    document.getElementById("jutsu-controls").innerHTML = "";
                    if (callback) callback();
                }
            }
        }

        function showMainScreen() {
            game.gameState = "main";
            let controls = document.getElementById("main-controls");
            controls.innerHTML = "";
            ["Train", "Manage Skills"].forEach(option => {
                let button = document.createElement("button");
                button.className = option === "Train" ? "train-button" : "skills-button";
                button.innerText = option;
                button.onclick = function() { handleMainOption(option); };
                controls.appendChild(button);
                log('Added ' + option + ' option');
            });
            updateSkillControls();
        }

        function handleMainOption(option) {
            log('Selected option: ' + option);
            if (option === "Train" && game.gameState !== "battle") {
                startBattle();
            } else if (option === "Manage Skills") {
                if (document.getElementById("skill-controls").innerHTML === "") {
                    updateSkillControls();
                } else {
                    document.getElementById("skill-controls").innerHTML = "";
                    log('Manage Skills menu closed.');
                }
            }
        }

        function updateSkillControls() {
            let controls = document.getElementById("skill-controls");
            controls.innerHTML = "";
            if (game.gameState === "main") {
                game.player.skillInventory.forEach((skill, index) => {
                    let button = document.createElement("button");
                    button.innerText = `Add ${skill.name} (${index + 1}) to Active`;
                    button.onclick = function() { moveToActiveSkills(skill, index); };
                    controls.appendChild(button);
                    log(`Added button to move ${skill.name} (${index + 1}) to active skills`);
                });
                game.player.skills.forEach((skill, index) => {
                    let button = document.createElement("button");
                    button.innerText = `Move ${skill.name} (${index + 1}) to Inventory`;
                    button.onclick = function() { moveToInventory(skill, index); };
                    controls.appendChild(button);
                    log(`Added button to move ${skill.name} (${index + 1}) to inventory`);
                });
            }
        }

        function moveToActiveSkills(skill, index) {
            if (game.player.skills.length < (game.player.Rank === "Student" ? 5 : game.player.Rank === "Genin" ? 10 : 15)) {
                game.player.skills.push(skill);
                game.player.skillInventory.splice(index, 1);
                log(`${skill.name} moved to active skills!`);
                updateSkillCount();
                updateSkillControls();
            } else {
                log('Active skills limit reached!');
            }
        }

        function moveToInventory(skill, index) {
            game.player.skillInventory.push(skill);
            game.player.skills.splice(index, 1);
            log(`${skill.name} moved to inventory!`);
            updateSkillCount();
            updateSkillControls();
        }

        function startBattle() {
    if (game.gameState !== "battle") {
        let enemyType = Math.random() < 0.5 ? new Mob("Wild Dog", 8, 8, "D-Rank", { Feral: "D-Rank" }, [new Skills().findSkill("Barrage")]) : new Mob("Training Dummy", 6, 6, "D-Rank", { Neutral: "D-Rank" }, [new Skills().findSkill("Barrage")]);
        game.enemy = enemyType;
        game.gameState = "battle";
        updateStatus();
        game.battleScene = { queueOutput: queueOutput };
        log('Entering battle...');
        queueOutput(`<span class="battle-ready">BATTLE BEGINS! ${game.player.name} vs. ${game.enemy.name}</span>`); // Fallback text
        setTimeout(() => determineTurnOrder(), 1000);
    } else {
        log('Battle already in progress!');
    }
        }

        function determineTurnOrder() {
            let coinFlip = Math.random() < 0.5;
            let first = coinFlip ? game.player.name : game.enemy.name;
            let second = coinFlip ? game.enemy.name : game.player.name;
            queueOutput(`${second} is off guard!`);
            setTimeout(() => takeTurn(first), 2000);
        }

        function takeTurn(name) {
            queueOutput(`${name}'s turn`);
            setTimeout(() => {
                let user = name === game.player.name ? game.player : game.enemy;
                let target = name === game.player.name ? game.enemy : game.player;
                applyStatusEffects(user);
                let skillSet = new Skills();
                let usableSkills = user.skills.filter(skill => skillSet.canUseSkill(user, skill));
                let skill = usableSkills.length > 0 ? usableSkills[Math.floor(Math.random() * usableSkills.length)] : null;
                if (skill && !user.statusEffects.some(e => e.name === "Numb")) {
                    skill.skillFunction(user, target, game.battleScene);
                } else if (user.statusEffects.some(e => e.name === "Numb")) {
                    queueOutput(`${user.name} is stunned by Numb!`);
                    user.statusEffects = user.statusEffects.filter(e => e.name !== "Numb");
                }
                if (game.player.hp > 0 && game.enemy.hp > 0) {
                    setTimeout(() => takeTurn(target.name), 2000);
                } else {
                    endBattle();
                }
            }, 2000);
        }

        function applyStatusEffects(entity) {
            entity.statusEffects = entity.statusEffects.filter(effect => {
                if (effect.name === "Burn" || effect.name === "Doom" || effect.name === "Bleed") {
                    entity.hp -= effect.damage;
                    effect.duration--;
                    queueOutput(`${entity.name} takes ${effect.damage} damage from ${effect.name}!`);
                    updateStatus();
                } else if (effect.name === "Healing") {
                    let heal = entity.hp < entity.maxHp ? effect.damage : 0;
                    entity.hp = Math.min(entity.maxHp, entity.hp + heal);
                    effect.duration--;
                    if (heal > 0) queueOutput(`${entity.name} heals ${heal} HP from ${effect.name}!`);
                    updateStatus();
                } else if (effect.name === "ShadowCloneEffect" || effect.name === "UltimateShadowCloneEffect") {
                    if (effect.new) {
                        effect.new = false;
                    } else if (effect.duration > 0) {
                        effect.duration--;
                    }
                } else if (effect.name === "Substitution" || effect.name === "RockBarrier") {
                    effect.duration--;
                }
                return effect.duration > 0;
            });
        }

        function queueOutput(msg) {
            game.outputQueue.push(msg);
            if (!game.isOutputting) processOutputQueue();
        }

        function processOutputQueue() {
            game.isOutputting = true;
            if (game.outputQueue.length > 0) {
                let msg = game.outputQueue.shift();
                game.output.push(msg);
                document.getElementById("output").innerHTML = game.output.join("<br>");
                setTimeout(processOutputQueue, 1000);
            } else {
                game.isOutputting = false;
            }
        }

        function endBattle() {
            game.gameState = "postBattle";
            queueOutput(`<span class="battle-ready">Battle ended!</span>`);
            performJutsuSelection(1);
        }
    </script>
</body>
</html>
